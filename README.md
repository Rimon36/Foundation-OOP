# Foundation-OOP
OOP Foundation in Bengali

#### অবজেক্ট এবং ক্লাস:
ক্লাস হচ্ছে অবজেক্টের জন্য টেমপ্লেট।অবজেক্ট তৈরী করার আগে একটা ক্লাস তৈরী করে নিতে হয় এবং এই ক্লাসটিকেই instantiate করলে এটা একটা অবজেক্ট হয়ে যায় ।

instantiate হচ্ছে এমন একটা পদ্ধতি যেটা ব্যবহার করলে একটা ক্লাস অবজেক্ট হয় এবং তখন সেই অবজেক্ট থেকে তার প্রোপার্টিজ এবং মেথডে একসেস নেয়া যায়।

একটা ক্লাসের ভিতর প্রোপর্টিজ এবং মেথড থাকবে। ক্লাসের ভিতর যেসব প্রোপার্টিজ এবং মেথড থাকবে সেগুলি যদি ব্যবহার করতে চান তাহলে ক্লাসটিকে আগে অবজেক্ট বানিয়ে নিতে হবে।

new শব্দটি দিয়ে নিচের মত করে কোড লিখে ক্লাস থেকে অবজেক্ট তৈরি করা  হয়। 

ক্লাস তৈরীর জন্য প্রথমেই class এই শব্দটি লিখে এরপর যেকোন নাম দিতে হয় আর এরপর দ্বিতীয় বন্ধনির (curly braces) ভিতর সব কোড লিখতে হয়।

```
<?php
class Product{
// all code goes here
}
$productObject = new Product();
?>
```
ক্লাসটিতে  যদি কোন প্রোপার্টিজ বা মেথড থাকত তাহলে $productObject এই হ্যান্ডল বা রেফারেন্সটির পর একটা অ্যারো (->) চিহ্ন দিয়ে সেই প্রোপার্টিজ বা মেথডে একসেস নেয়া যেত।

$productObject হ্যান্ডল বা রেফরেন্সটি কোথাও অবজেক্ট বলতে শুনতে পারেন।
একটা ক্লাসের একাধিক অবজেক্ট তৈরী করতে পারেন। অবজেক্টগুলি একই ক্লাসের তবুও তারা সম্পূর্ন ভিন্ন।

যদি ক্লাসের ভিতর  কখনও প্রোপার্টিজকে পরিবর্তন করার প্রয়োজন হয় তাহলে $this এই সিডো ভেরিয়েবলটি ব্যবহার করে করতে পারেন যেমন আমি $title এর একটা ডিফল্ট মান দিয়ে রেখেছি,
আপনি চাইলে $this->title = "modified value"; এভাবে  মান পরিবর্তন করে দিতে পারেন।
আর অবজেক্টে যদি পরিবর্তন করতে চান তাহলে $productObject->title = "modified in object"; এভাবে করতে পারবেন।

#### প্রোপার্টিজ এবং মেথড :  
ক্লাসের ভিতর ভেরিয়েবলকে বলা হয় প্রোপর্টিজ বা মেম্বার ভেরিয়েবল এবং ফাংশনকে বলা হয় মেথড বা মেম্বার ফাংশন বা (behaviour)বিহেবিয়ার।

#### প্রোপার্টিজ  (Properties) : 
প্রোপার্টি হচ্ছে সাধারন পিএইচপি ভেরিয়েবলের মত,ক্লাসের ভিতরে থাকলে এদেরকে প্রোপার্টি বা মেম্বার ভেরিয়েবল বলে।
ক্লাসের ভিতর প্রয়োজন হলে এই মান পরিবর্তন করতে পারেন,সাধারন ভেরিয়েবলের মত।
প্রোপার্টিজকে কোথাও কোথাও attributes বা মেম্বার ভেরিয়েবল বলতে শুনতে পারেন।একই জিনিস।
ক্লাস ডিক্লেয়ার করার পর দ্বিতীয় বন্ধনীর ভিতর স্ক্রিপ্টের শুরুতেই প্রোপার্টিজ লিখতে হয়।

#### মেথড (Method): 
ক্লাসের ভিতর ফাংশনকে মেথড বলা হয়।প্রোপার্টিজ ডেটা সংরক্ষন করার জন্য আর মেথড কোন একটা কাজ পরিচালনা করার জন্য।
প্রথমে এ function শব্দটি এবং এরপর মেথডের নাম,এভাবে মেথড লেখা হয়।

#### কনস্ট্রাক্টর মেথড (Constructor Method) : 
পিএইচপি ক্লাসে কনস্ট্রাক্টর একটা বিশেষ মেথড।ইচ্ছে করলে ক্লাস তৈরীর সময় কনস্ট্রাক্টর মেথড নাও দিতে পারেন।
যদি দেন তাহলে এই ক্লাসটিকে instantiation করার সময় (অর্থ্যাৎ অবজেক্ট তৈরীর সময়) এই মেথডটি অটোমেটিক কল হবে।
আর সহজভাবে বলতে গেলে কনস্ট্রাক্টর হচ্ছে এমন একটি কোডব্লক যেটা অবজেক্ট তৈরীর সময়ই অটোমেটিক এক্সিকিউট হয়।কনস্ট্রাক্টর মেথড লিখতে হয় দুটি আন্ডারস্কোর (__) এবং এরপর construct শব্দটি দিয়ে।
কনস্ট্রাক্ট মেথডে, এই ক্লাসে থাকা অন্য কোন মেথড একসেস নিতে পারেন $this->methodName()।
কনস্ট্রাক্ট মেথডে প্রোপার্টিজের যে মানগুলি সেট করবেন সেগুলি instantiation এর সময় ফাংশনের প্যারামিটার যেভাবে পাঠানো হয় সেভাবে দিতে হবে।

#### ডিস্ট্রাক্টর মেথড (Destructor Method) : 
new শব্দ দিয়ে অবজেক্ট তৈরীর সাথে সাথেই সার্ভারের মেমরিতে এই অবজেক্ট তৈরী হয় ।  অবজেক্টটির কাজ শেষ হয়ে যাবে তখন অটোমেটিক পিএইচপি মেমরি থেকে এই অবজেক্ট সরিয়ে দেবে। 
চাইলে ম্যানুয়ালী এই অবজেক্ট সরিয়ে দিতে পারেন।পিএইচপি এইজন্য destruct মেথডের সুবিধা দিয়েছে যেটাকে প্যারামিটার ছাড়া অবজেক্টের শেষে রাখতে হয়।
অবজেক্ট শেষ হওয়ার আগে পিএইচপি ইন্জিন এই destruct মেথডকে খোজে।যদি পায় তাহলে মেমরি পরিস্কার করে এবং অন্যান্য সব অবজেক্টের সাথে সংযোগ বিচ্ছিন্ন করে নেয়।

#### এনক্যাপসুলেশন (Encapsulation) এবং একসেস মডিফায়ার  : 
সহজভাবে বলতে গেলে এনক্যাপসুলেশন এমন একটা পদ্ধতি যেটা দ্বারা স্ক্রিপ্টে প্রোপার্টিজ,মেথড ইত্যাদির স্কোপ ঠিক করে দেয়া যায়। 
মেথড/প্রোপার্টিজকে একসেস মডিফায়ার দিয়ে ডেটাগুলি অবজেক্টে বিভিন্নভাবে মোড়ানো থাকার কারনে যে সুরক্ষা পাওয়া যায় , সেইটাই এনক্যাপসুলেশন।
একসেস মডিফায়ার (public, private এবং protected) দিয়ে এই এনক্যাপসুলেশন এর কাজ করা হয়। 

PHP: কোন মেথড বা প্রোপার্টিজের সামনে যদি কিছু না থাকে তাহলে বাই ডিফল্ট এটি public থাকে।

public		: মেথড বা প্রোপার্টিজকে স্ক্রিপ্টের যেকোন জায়গা থেকে দেখা যাবে এবং একসেস বা মডিফাই করা যাবে।

private		: মেথড বা প্রোপার্টিজকে শুধুমাত্র এই ক্লাস থেকে দেখা যাবে এবং একসেস বা মডিফাই করা যাবে।

protected	: মেথড বা প্রোপার্টিজকে এই ক্লাস এবং এর প্রতিপাদিত ক্লাস থেকে একসেস বা মডিফাই করা যাবে।

#### ইনহেরিটেন্স (Inheritence) :
ইনহেরিটেন্স এর মাধ্যমে অনেক ক্লাসের একই রকম প্রোপার্টিজ এবং মেথড একটা ক্লাসে (প্যারেন্ট ক্লাসে) কমন রাখা যায়। এই প্যারেন্ট ক্লাস থেকে অন্যান্য চাইল্ড ক্লাস (child class) বা প্রতিপাদিত ক্লাস (derived class) বানানো যায়।
যখন কোন প্যারেন্ট ক্লাস থেকে extends কিওয়ার্ড দিয়ে কোন ক্লাসকে inherit করবেন  তখন চাইল্ড ক্লাসগুলি অটোমেটিক প্যারেন্ট ক্লাসের মেথড এবং প্রোপার্টিজগুলি পেয়ে যাবে এমনকি কনস্ট্রাক্টর মেথড।

#### কনস্ট্রাক্টর মেথড এবং ইনহেরিটেন্স:

** যদি প্যারেন্ট ক্লাসে কনস্ট্রাক্টর থাকে এবং চাইল্ড ক্লাসে না থাকে তাহলে চাইল্ড ক্লাস instantiate করলে প্যারেন্ট ক্লাসের কনস্ট্রাক্টর সেই চাইল্ড ক্লাসে কল হবে।

** যদি চাইল্ড ক্লাসে কনস্ট্রাক্টর মেথড থাকে এবং সেই চাইল্ড ক্লাস instantiate করা হয় তাহলে আর প্যারেন্ট ক্লাসের কনস্ট্রাক্টর মেথড কল হবেনা বরং এখানে যে  কনস্ট্রাক্টর মেথডটি আছে সেটিই এক্সিকিউট হবে।

==> আসলে চাইল্ড ক্লাস instantiate করার পর কোন মেথড বা প্রোপার্টিজকে কল করলে পিএইচপি ইন্জিন আগে সেই চাইল্ড ক্লাসে কলকৃত প্রোপার্টিজ বা মেথড খোজে,যদি না পায় তখন প্যারেন্ট ক্লাসে গিয়ে খোজে।আর যদি পায় তাহলে আর প্যারেন্ট ক্লাসে যায়না।

** যদি চাইল্ড ক্লাসে প্যারেন্ট ক্লাসের কনস্ট্রাক্টর প্রয়োজন হয় তাহলে চাইল্ড ক্লাস এর construct মেথড এর ভিতরে  parent::__construct 

এই কিওয়ার্ড ব্যবহার করে প্যারেন্ট ক্লাসের কনস্ট্রাক্ট মেথডে ডাকতে পারেন।
এতে করে প্যারেন্ট ক্লাসের কনস্ট্রাক্ট মেথড এর সাথে চাইল্ড ক্লাসের অতিরিক্ত কাজটুকু যোগ হয়ে গেছে। এখানে কনস্ট্রাক্ট মেথড ওভাররাইড করা হয়েছে।

#### মেথড ওভাররাইডিং (Method Overriding) : 
প্যারেন্ট ক্লাসের মেথড এবং প্রোপার্টিজ চাইল্ড ক্লাসে একসেস পাওয়া যায়ে। প্যারেন্ট ক্লাসের কোন মেথড যদি চাইল্ড ক্লাসে লিখেন এবং 
এখানে নতুন কিছু যোগ করে এই চাইল্ড ক্লাসকে instantiate করেন তাহলে যখন এই চাইল্ড ক্লাসের এই মেথড কল করবেন তখন আর প্যারেন্ট ক্লাসের মেথড এক্সিকিউট হবেনা। বরং একই নাম হওয়া স্বত্তেও চাইল্ড ক্লাসের মেথডটিই এক্সিকিউট হবে।

তবে যখন চাইল্ড ক্লাসের ভিতর parent::methodName() এভাবে দিবেন তখন পিএইচপি ইন্জিন প্যারেন্ট ক্লাসে যাবে এবং চাইল্ড ক্লাসের parent::methodName() এই লাইনের জায়গায় প্যারেন্ট ক্লাসের আউটপুট টুকু প্রবেশ করিয়ে দেবে।
construct মেথডও ওভাররাইড করা যায় (একই নিয়ম)।

#### টাইপ হিন্টিং (Type hinting):
একটা ফাংশনের প্যারামিটার হিসেবে একটা অবজেক্ট পাঠানো যায়।যখন একটা ক্লাসের কোন মেথডে কোন অবজেক্টকে প্যারামিটার হিসেবে পাঠাবেন তখন এটা ঠিক করে দিতে পারেন যে এই অবজেক্ট টি কোন্ ক্লাসের instantiation হবে (অর্থ্যাৎ কোন্ অবজেক্ট হবে)।
এটা করার জন্য শুধুমাত্র প্যারামিটারের আগে ক্লাসের নামটি দিতে হয়।এটাই হল টাইপ হিন্টিং (Type Hinting)।যেমন:
```
public function getTeacher(DepartmentInfo $dept)

$dept = new DepartmentInfo("CSE");

$tinfo = new TeacherInfo("Kaykobad");
$tinfo->getTeacher($dept);
```

#### পলিমরফিজম (Polymorphism) :
অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং এর মুল ৩টি বিষয়ের একটি হল পলিমরফিজম আর বাকি দুটি হচ্ছে ইনহেরিটেন্স এবং এনক্যাপসুলেশন।
ধরুন আপনি একটি স্ক্রিপ্ট লিখলেন যেখানে একটা প্যারেন্ট ক্লাস আছে এবং এখানে একটি display() নামে মেথড আছে,আর এটাকে extends করে আরও কয়েকটি চাইল্ড ক্লাস বানালেন এবং সবগুলি চাইল্ড ক্লাসেই এই নামের (display) একটি করে মেথড রাখলেন।
এখন প্যারেন্ট ক্লাস instantiate করে display মেথড কল করলে যে কাজ করবে,ধরুন C নামে একটি চাইল্ড ক্লাস আছে এবং এই চাইল্ড ক্লাস instantiate করে display মেথড কল করলে অন্য কাজ হবে (যেহেতু সব চাইল্ড ক্লাসে display মেথড আছে)।

এটাই হচ্ছে পলিমরফিজম।একই মেথড বিভিন্ন ক্লাসে বিভিন্ন কাজ করবে প্যারামিটার ইত্যাদির উপর ভিত্তি করে।

**এনক্যাপসুলেশনের কারনে একই নাম হওয়াতে কোডে কোন conflict হবেনা।

**মেথড ওভাররাইডিং পলিমরফিজমের উৎকৃষ্ট উদাহরন।

**যখন প্যারেন্ট ক্লাস বা এর কোন চাইল্ড ক্লাসকে instantiate করবেন এবং display মেথড কল করবেন তখন পিএইচপি ইন্জিন অটোমেটিক বুঝে নেয় যে এখন কোন্ display মেথডটিকে এক্সিকিউট করাতে হবে (অর্থ্যাৎ যে অবজেক্টের display মেথড কল করবেন সেটাই এক্সিকিউট হবে )।

#### স্টাটিক প্রোপার্টিজ এবং মেথড (Static Properties and Method) :
এতক্ষন আমরা দেখেছি পিএইচপিতে কোন ক্লাসের মেথড বা প্রোপার্টিজে একসেস পাওয়ার জন্য সেই ক্লাসকে আগে instantiate করে অবজেক্ট বানিয়ে নিতে হয়।যাইহোক যদি কোন ক্লাসে স্টাটিক মেথড বা প্রোপার্টিজ থাকে তাহলে instantiate করা ছাড়াই (অর্থ্যাৎ অবজেক্ট বানানো ছাড়াই) এই মেথড বা প্রোপার্টিজে একসেস নেয়া যায়।
```
<?php

class DepartmentInfo {

public static $departmentName;
public static $chairman;

public static function departmentHead($dName, $chair) {
self::$departmentName = $dName;
self::$chairman = $chair;
echo "Department - " . self::$departmentName . "<br/>" . "Chaiman - " . self::$chairman . "<br/>";
}

}

DepartmentInfo::departmentHead("Statistics", "Dr. Rowshan jahan");
echo DepartmentInfo::$departmentName;
?>
```
** কোন ক্লাসে স্টাটিক মেথড বা প্রোপার্টিজ এর প্রয়োজন হলে একসেস মডিফায়ার (public, private, protected কিওয়ার্ড) এর পর static শব্দটি দিতে হবে।

** স্টাটিক মেথডে স্টাটিক প্রোপার্টিজ এর একসেস প্রয়োজন হলে self এবং এরপর :: দিতে হবে।(যেমন আমি নিয়েছি self::$chairman)

**যেহেতু ক্লাসের instantiation ছাড়াই মেথড এবং প্রোপার্টিজে একসেস নেয়া যায় তাই এদেরকে সাধারনত  মেথড ও প্রোপার্টিজ এর পরিবর্তে যথাক্রমে ক্লাস মেথড এবং ক্লাস ভেরিয়েবল বলে।

**স্টাটিক মেথডে শুধুমাত্র স্টাটিক ভেরিয়েবল একসেস নেয়া সম্ভব,কোন ভেরিয়েবল যদি স্টাটিক না হয় তাহলে $this সিডো ভেরিয়েবল ব্যবহার করে একসেস নেয়া সম্ভব নয় কারন এই ক্লাসের instantiation করা হচ্ছেনা।

**স্টাটিক মেথড বা প্রোপার্টিজ স্ক্রিপ্টে গ্লোবাল ভেরিয়েবলের মত,যেকোন জায়গা থেকে একসেস নেয়া যায় (ক্লাসের নাম তারপর ডাবল ক্লোন চিহ্ন দিয়ে যেমন:DepartmentInfo::$departmentName এভাবে)।

**ক্লাসের ভিতরে একসেস নিতে self তারপর ডাবল ক্লোন চিহ্ন আর ক্লাসের বাইরে হলে className:: এভাবে (উপরের নিয়মটির মত)

** :: এই ডাবল ক্লোনকে স্কোপ রেজুলেশন অপারেটরও বলে

**  ক্লাসের স্টাটিক মেথডে self ব্যবহার করলে ইনহেরিটেন্স ঠিকভাবে কাজ করবেনা। এই সমস্যা দুর করতে static ব্যবহার করতে হবে self এর স্থলে।
```
<?php
class User {
  static protected $r = 'normal user';
  public static function tester() {
   echo static::$r;
 }
}
class Agent extends User {
 static protected $r = 'This is agent';
}
Agent::tester();
?>
```

#### এবস্ট্রাক্ট মেথড এবং ক্লাস (Abstract Method and Class) :
এবস্ট্রাক্ট ক্লাস instantiate করা যায়না তবে inherit করা যায়।এখানে থেকে বের হওয়া চাইল্ড ক্লাসের instantiate করা যায়।
এবস্ট্রাক্ট ক্লাস বানানো হয়েছে এর চাইল্ড ক্লাসে কি কি থাকবে সেই নির্দেশনা যাতে প্রোগ্রামার প্যারেন্ট ক্লাসটি (এবস্ট্রাক্ট ক্লাস) দেখে বুঝতে পারে।

```
<?php
 
abstract class DepartmentInfo {
 
abstract public function departmentActivity();
}
 
class StatisticsDept extends DepartmentInfo {
 
public function departmentActivity() {
echo "Statistics department arrange a tour yearly<br/>";
}
 
}
 
class CseDept extends DepartmentInfo {
 
public function departmentActivity() {
echo "CSE department should arrange programming contest";
}
 
}
 
$sdept = new StatisticsDept();
$sdept->departmentActivity();
$cdept = new CseDept();
$cdept->departmentActivity();
?>
```
ব্যাখ্যা:
**এখানে দেখুন প্যারেন্ট ক্লাসটি এবস্ট্রাক্ট এবং এখানে একটি এবস্ট্রাক্ট মেথড আছে।তাই এখানে থেকে প্রতিপাদিত প্রতিটি চাইল্ড ক্লাসেও এই মেথডটি রাখতে হয়েছে।যদি না রাখতাম তাহলে এরর দেখাত।

**চাইল্ড ক্লাসে মেথডগুলি ডিফাইন করার পর ইচ্ছেমত বডি দিতে পারবেন (এই মেথডের ভিতর কোড দিতে পারবেন)।তবে প্যারেন্ট ক্লাসটিতে (এবস্ট্রাক্ট ক্লাসটিতে) এবস্ট্রাক্ট মেথডে কোন বডি থাকবেনা।

**এবস্ট্রাক্ট প্যারেন্ট ক্লাসে এবস্ট্রাক্ট মেথড ছাড়া অন্য সাধারন মেথড রাখতে পারেন এবং এসব মেথডের বডি থাকতে পারে।এটাই ইন্টারফেস ক্লাসের সাথে এবস্ট্রাক্ট ক্লাসের পার্থক্য 

**যদি কোন ক্লাসে একটা এবস্ট্রাক্ট মেথড থাকে তাহলে সেই ক্লাসকেও অবশ্যই এবস্ট্রাক্ট ডিক্লেয়ার করতে হবে।

**প্যারেন্ট ক্লাসে যতগুলি এবস্ট্রাক্ট মেথড থাকবে,এখান থেকে বের হওয়া সব চাইল্ড ক্লাসেও সেই মেথডগুলি থাকতে হবে।

**এবস্ট্রাক্ট ক্লাস তৈরীর জন্য ক্লাসের নামের আগে শুধু abstract শব্দটি দিতে হয় আর এবস্ট্রাক্ট মেথড তৈরীর জন্য একসেস মডিফায়ার এর আগে abstract শব্দটি দিতে হয়।

#### ইন্টারফেস ক্লাস (Interface Class) : 
এর আগে এবস্ট্রাক্ট ক্লাস সম্পর্কে আলোচনা হয়েছে।এবস্ট্রাক্ট ক্লাস আর ইন্টারফেস ক্লাস হুবহু একই শুধু পার্থক্য হচ্ছে এবস্ট্রাক্ট ক্লাসে এবস্ট্রাক্ট মেথড ছাড়াও অন্য মেথড থাকতে পারে এবং এই মেথডের ভিতর কোড থাকতে পারে (সাধারনত এটাকে মেথড বডি বলে) আর ইন্টারফেস ক্লাসে কোন মেথডে বডি থাকতে পারবেনা।

*ইন্টারফেস ক্লাস অন্যান্য ক্লাসের মতই লিখতে হয়,এখানে class শব্দের পরিবর্তে interface শব্দ ব্যবহৃত হয়।

*ইন্টারফেস ক্লাস থেকে ইন্টারফেস ক্লাস extend করা যায়।

*ইন্টারফেস ক্লাস extends (ইনহেরিট) এবং instantiate করা যায়না বরং (চাইল্ড ক্লাসে) implements করা যায়।যেমন
```
<?php


interface Moveable {


public function move();
}


class Man implements Moveable {


public function move() {
echo "A man can move<br/>";
}


}


class Vehicle implements Moveable {


public function move() {
echo "A Vehicle also can move";
}


}


$mans = new Man();
$mans->move();
$machine = new Vehicle();
$machine->move();
?>
```
ব্যাখ্যা:এখানে দেখুন Moveable ইন্টারফেসকে implements করেছে Man এবং Vehicle ক্লাসে।ইন্টারফেস ক্লাসে যেসব মেথড থাকবে সেই মেথডগুলি এর implement করা ক্লাসে অবশ্যই থাকতে হবে এবং এখানে প্রয়োজন অনুযায়ী মেথড বডি থাকবে।এটা নিয়ম।

**ইন্টারফেস ক্লাসে যেসব মেথড থাকবে সেগুলি অবশ্যই পাবলিক হতে হবে।

**দুটি অবেজক্টের মধ্যে যদি কোন সম্পর্ক না থাকে শুধুমাত্র ২/১টি মেথডে মিল আছে এমন হলে সাধারনত সেই অবজেক্টগুলির জন্য একটা ইন্টারফেস ক্লাস বানানো হয়।

যেমন উপরের উদাহরনে দেখুন Man এবং Vehicle এর মধ্যে তেমন কোন মিল নেই তবে দুটোই চলতে পারে তাই এখানে এদের জন্য Moveable ইন্টারফেস নেয়া হয়েছে।যদি খুব মিল থাকত তাহলে তো ইনহেরিটেন্স দিয়েই কাজ হয়ে যেত।

**ইন্টারফেস ব্যবহারের আরকেটি সুবিধা হচ্ছে যখন একসাথে অনেক প্রোগ্রামার কাজ করবে তখন হয়ত প্রজেক্ট ম্যানেজার একটা ইন্টারফেস তৈরী করে জুনিয়র প্রোগ্রামার কে দিয়ে দেবে।এতে জুনিয়র প্রোগ্রামারকে আর এপ্লিকেশন নিয়ে ভাবতে হবেনা,সে শুধু ইন্টারফেস দেখে দেখে তার ক্লাসগুলিতে মেথডগুলি পূর্ন (মেথডে কোড লিখবে) করবে।

**একসাথে একাধিক ইন্টারফেস একটা ক্লাসে implements করা যায়।যেমন

```
<?php

interface Moveable {

public function move();
}

interface Test {

public function testMove();
}

class Man implements Moveable, Test {

public function move() {
echo "A man can move<br/>";
}

public function testMove() {
echo "Multiple Interface multiple inheritence<br/>";
}

}

class Vehicle implements Moveable {

public function move() {
echo "A Vehicle also can move";
}

}
$mans = new Man();
$mans->move();
$mans->testMove();
$machine = new Vehicle();
$machine->move();
?>
````
#### ক্লাস অটোলোড করা (Autoloading Class) :
একটা ক্লাসকে ব্যবহার করার আগে তাকে সংযুক্ত করতে হয়।সাধারনত আমরা require_once বা include ইত্যাদি ফাংশন দ্বারা আগে প্রয়োজনীয় ক্লাসগুলি সংযুক্ত করি এরপর এগুলি দিয়ে কাজ শুরু করি।যেমন
```
<?php
require_once 'class.WebcoachbdProduct.php';
require_once 'class.UserLogin.php';
$productObject = new WebcoachbdProduct();
$productObject->getTutorial(' OOP');
?>
```
কিন্তু যদি আপনার প্রজেক্টে ১৫০/২০০ টি ক্লাস থাকে এবং কোন স্ক্রিপ্টে যদি ১০০টি ক্লাস লাগে তাহলে সবগুলি এভাবে require_once দিয়ে যোগ করবেন?

উত্তরে বলুন না,কারন এই বিরক্তিকর কাজ থেকে মুক্তির জন্য এবার ক্লাস অটোলোড ফাংশনটির কাজ শিখবেন।যাইহোক ক্লাস অটোলোড ফাংশন কাজ করানোর জন্য দুটি বিষয় অবশ্যই অনুসরন করতে হবে

-একটা ফাইলে একটা ক্লাস রাখতে হবে

-ফাইল এবং ক্লাসের নাম দেয়ার সময় কোন একটা naming convention অনুসরন করতে হবে।

যেমন দেখুন আমার ফাইলগুলি আমি নাম দিয়েছি এভাবে class.WebcoachbdProduct.php, class.DepartmentInfo.php ইত্যাদি এবং এই ফাইলগুলিতে ক্লাসের নাম দিয়েছি এভাবে class WebcoachbdProduct, class DepartmentInfo ..

এখন এই ক্লাসগুলি আমি অটোলোড করাতে পারি এভাবে
```
<?php
function __autoload($class_name){
require_once 'class.' . $class_name . '.php';
}
$prod = new WebcoachbdProduct();
$prod->getTutorial(' Framework');
?>
```
২,৩,৪ নম্বর লাইনে যে ফাংশনটি আছে এটাই ক্লাস অটোলোড করবে।যে ক্লাসকেই instantiate করুন না কেন,সাথে সাথে সেই ক্লাসকে এই ফাংশন অটোমেটিক লোড করবে।যেমন আমি যখনই ৫ নম্বর লাইনে new এর পর ক্লাসের নামটি লিখেছি সাথে সাথে এই নামটি ফাংশনটির $class_name এর জায়গায় গিয়ে বসে গেছে এবং এরপর ৩ নম্বর লাইন দিয়ে ক্লাস টি যোগ হয়েছে।এভাবে যদি new UserLogin দিতাম তাহলে UserLogin ক্লাসটি অটোলোড হতো যেটা class.UserLogin.php ফাইলে আছে।

**যদি পিএইচপি ফাইলগুলি অন্য কোন ফোল্ডারে থাকে তাহলে require_once এ উল্লেখ করে দিলেই হবে।যেমন আমি আমার ক্লাস ফাইলগুলি যদি test ফোল্ডারে রাখি তাহলে তখন নিচের মত করে অটোলোড করাতে হবে।
```
<?php
function __autoload($class_name){
require_once 'test/class.' . $class_name . '.php';
}
$prod = new WebcoachbdProduct();
$prod->getTutorial(' Framework');
?>
```

#### ম্যাজিক মেথড (Magic Method) : 
পিএইচপিতে অনেকগুলি ম্যাজিক মেথড আছে,ইতোমধ্যে আমরা দুটি দেখেছি এবং এদের ব্যবহার শিখেছি।__construct() এবং __autoload() মেথড।ম্যাজিক মেথডগুলি ডাবল আন্ডারস্কোর (__) দিয়ে শুরু হয় এবং সবগুলির একটা কমন বৈশিষ্ট্য আছে তাহল এই মেথডগুলি কখনও কল করতে হয়না বরং অটোমেটিক এক্সিকিউট হয় (পরিস্থিতির উপর ভিত্তি করে)।যেমন কনস্ট্রাক্ট এবং অটোলোড মেথড কখন অটোমেটিক এক্সিকিউট হয় তা আমরা আগের টিউটোরিয়ালগুলিতে দেখেছি।যাইহোক এরুপ আরও ম্যাজিক মেথড আছে,এখান থেকে সবসময় কাজে লাগে এরুপ কয়েকটি নিয়ে আলোচনা করা হচ্ছে-

__get() ম্যাজিক মেথড:

এই মেথডটি কল হয় যখন এমন কোন প্রোপার্টিজে একসেস নেয়া হয় যেটা ক্লাসে নেই।

__set() মেথড:

এই মেথডটি অটোমেটিক কল হয় যখন, ক্লাসে নেই এমন কোন প্রোপার্টিজ এর মান পরিবর্তন করবেন।

*এই মেথডদুটি দিয়ে ডাইনামিকালি প্রোপার্টিজ তৈরী হয়।অর্থ্যাৎ যখন এমন কোন প্রোপার্টিজ এর মান পরিবর্তন করবেন যেটার অস্তিত্ব ক্লাসে নেই তখন সাথে সাথে __set মেথড কল হবে এবং ক্লাসে ঐ নামে একটি প্রোপার্টিজ তৈরী করে তার মান ঐটা করে দেবে যেটা আপনি দিলেন।

*আর যখন এই প্রোপার্টিজটি তে একসেস নিতে চাইবেন (ধরুন আপনার সেট করা মানটি echo করে দেখতে চান) তখন __get মেথড কল হবে।বুঝতে যদি একটু সমস্যা হয় তাহলে নিচের উদাহরনটি দেখে সেটুকু দুর করুন।

*এইভাবে ম্যাজিক মেথড দিয়ে প্রোপার্টিজ ডাইনামিকালি তৈরীর প্রক্রিয়াকে প্রোপার্টি ওভারলোডিং বলে।অন্যান্য ল্যাংগুয়েজেও ওভারলোডিং আছে তবে সেখানে এই কাজ হয়না যেটা পিএইচপিতে হচ্ছে।

#### __toString() মেথড:

যখন একটা অবজেক্টকে print বা echo করবেন তখন এই মেথডটি অটোমেটিক কল হবে যদি ঐ ক্লাসে এই মেথডটি থাকে,আর যদি না থাকে তাহলে এরর দেখাবে।একটা অবজেক্টকে স্ট্রিং এ রুপান্তর করার জন্য এই মেথড ব্যবহৃত হয়।যেমন:
```
<?php


class WebcoachbdProduct {


public $title = "default value";
public $length;


public function getTutorial($name) {
echo "Webcoachbd provide massive tutorial on" . $name;
}
public function __toString() {
return $this->title;
}


}


$productObject = new WebcoachbdProduct();
echo $productObject;
?>
```
আউটপুট:

default value

**এই মেথড দিয়ে যেকোন কিছু রিটার্ন করতে পারেন।যেটা রিটার্ন করবেন সেটাই দেখাবে (অবজেক্ট কে echo বা print করলে)

**এই মেথডে শুধু return করতে হবে,এখান থেকে কোন কিছু সরাসরি echo বা print করবেন না।

**কোন অবজেক্টে যদি জটিল ধরনের মেম্বার ভেরিয়েবল থাকে তাহলে সেগুলিকে দেখার জন্য সাধারনত এই মেথড ব্যবহার করা হয়।যেমন ডেটাবেস কানেকশন,নেটওয়ার্ক ইত্যাদি।


ক্লাস কনস্টান্ট:

একটা ক্লাসে আপনি ইচ্ছে করলে কনস্টান্ট রাখতে পারেন।এই কনস্টান্ট এর মান যেটা দিবেন সেটা পুরো স্ক্রিপ্টে সবসময় ঐটাই থাকবে,কখনও পরিবর্তন হবেনা।যেমন
```
<?php


class WebcoachbdProduct {


public $title = "default value";
const PI  = "3.1416";


public function getTutorial($name) {
echo "Webcoachbd provide massive tutorial on" . $name;
}


}


$productObject = new WebcoachbdProduct();
echo $productObject::PI;
?>
```
আউটপুট

3.1416

**সাধারনত এরুপ মান যেসব কখনও পরিবর্তন হবেনা (যেমন PI এর মান)এগুলি উপস্থাপনের জন্য কনস্টান্ট ব্যবহার করা হয়।


#### নেমস্পেস (Namespace) :
```
<?php
namespace Framework {
class Webcoachbd {
    public $title = "default value";
    public function getTutorial($name) {
    echo "Webcoachbd provide massive tutorial on" . $name;
    }
  }
}
namespace OOPHP {
class Webcoachbd {
   public $title = "different value";
   public function getTutorial($name) {
   echo "Webcoachbd provide massive tutorial on" . $name . "<br/>";
   }
  }
}

$objWeb = new OOPHP\Webcoachbd();
$objWeb->getTutorial(' OOPHP');
$objFrm = new Framework\Webcoachbd();
$objFrm->getTutorial(' Framework');

?>
```
*namespace স্ক্রিপ্টের শুরুতে ডিফাইন করতে হবে আর কল করার সময় namespace এর নামের পর ব্যাকস্ল্যাশ দিয়ে ক্লাসের নাম দিতে হবে (যেমন আমি ৪ এবং ৬ নম্বর লাইনে দিয়েছি)
